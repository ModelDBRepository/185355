/* =============================================================================

    DENTATE GYRUS MODEL

    This is from the models of
        - Yim MY, Hanuschkin A, Wolfart J (2015) Hippocampus 25:297-308.
        - Santhakumar V, Aradi I, Soltesz I (2005) J Neurophysiol 93:437-53 
        
    History: Modified by 
        - Abraham Nunes / 2022
        - Man Yi Yim / 2015
        - Alexander Hanuschkin / 2011

============================================================================= */


// Which figure (1-5) do you want to simulate?
// Please use the original parameters to produce the figures.
// If you want to run the simulation with your own parameters, set fig = 0
fig = 1

// LOAD SIMULATION PARAMETERS 
err_ = load_file("set-simparams.hoc")

objref cells ,Gcell[ngcell], Bcell[nbcell], Mcell[nmcell], Hcell[nhcell]
objref PPSt[npp], PPSt_noise[npp]
objref nclist, netcon
objref vgc2gc, vgc2bc, vgc2mc, vgc2hc
objref vbc2gc, vbc2bc, vbc2mc
objref vmc2gc, vmc2bc, vmc2mc, vmc2hc
objref vhc2gc, vhc2bc, vhc2mc
objref pp2gc, pp2bc, pp2hc


// LOAD PSEUDORANDOM NUMBER GENERATOR 
//  NOTE: 
//      - all NetStims share the same random number generator  
//      - used solution given in http://www.neuron.yale.edu/neuron/node/61
err_ = load_file("ranstream.hoc")


// INITIALIZE CVODE 
objref cvode
cvode = new CVode()
using_cvode_ = 1
debug_ 		 = 2   // print output (everything: debug==1; some: debug==0 ) 


if (PP_input2MC_ != 0) {
    print "PP stimulation not yet implemented if stimulation of also MCs...."      
    quit()
}



// for debug purpose only...
objref netcon, nil
objref vec_debug_
objref PP_init_rnd		// random number generator to select an PP stimulus site..
objref nslist, rslist, rs_noiselist
objref ns, rs

//Generate spike matrix and save to file
objref Spike[ntotal-1], Spike_times[ntotal-1]
for i=0, (ngcell+nbcell +nmcell +nhcell -1) {
    // vector of spikes for each cell
    Spike[i] = new Vector()      
    // vector of spike times for each cell  
    Spike_times[i] = new Vector()
}
strdef Spkstr
objref dfile
dfile = new File()

// INITIALIZE CELL POPULATIONS 
err_ = load_file("initialize-cells.hoc")

//STIM
//record input stimulus for debug purpose
objref vec_stim[npp]
for i = 0, npp-1 { vec_stim[i] = new Vector() }

// record input noise for debug purpose
objref vec_stim_noise[npp]
for i = 0, npp-1 { vec_stim_noise[i] = new Vector() }
objref pprec 							// vector if recorded from PP 

// record Poisson in for debug purpose
objref distri_gc_input_
distri_gc_input_ = new Vector()

// CONNECTING CELLS
err_ = load_file("connectivity.hoc")

err_ = ropen("/proc/uptime")			// get a seed that is changing based on the processing time
	 {			
 	//rseed = fscan()		// so simulation will not start with the same seed (original) // Fscan() reads the next number from the file opened with the ropen() command
	rseed = trial 			// set the seed to trialnumber, to get reproduceable connectivity and responses
	ropen()		
	}




objref VmT                  // vector of time points
objref VmMat[cells.count]   // for each cell vector of Membrane potential

VmT = new Vector()
for i=0, cells.count-1 {
    VmMat[i] = new Vector()
}

// procedure called in every time step to add voltage of recorded cell at time t
proc VecMx() { local i                		
    VmT.append(t)
    for i=0, (ngcell+nbcell +nmcell +nhcell -1) {
        VmMat[i].append( cells.object[i].soma.v(0.5))
    }
}


proc ConvVT2Sp() { local i, j, max_id
    max_id = npp
    if (  print_template ==1) { max_id = npp }
  	if (  print_Raster ==1) { max_id = ngcell+nbcell +nmcell +nhcell-1 }

    for i=0, (max_id) {
        Spike[i].spikebin(VmMat[i], 0)          // Used to make a binary version of a spike train.
                                                // <data> is a vector of membrane potential.
                                                // <thresh> is the voltage threshold for spike detection.
                                                // <v> is set to all zeros except at the onset of spikes (the first dt which the spike crosses threshold)
    }
}


// PRINT FILES
err_ = load_file("printfile.hoc")


// SET UP STIMULATOR FOR PP
err_ = load_file("init-stim.hoc")



objref dataset, data_
proc read_custominit() { local i
  data_ = new Vector()
  dataset = new File()
  err_ = dataset.ropen(init_state_fname_)
  if (err_ == 0) {
        print "IO code:",err_
        print "Initial State File not found!"
        quit()
  }

  err_ = data_.scanf(dataset)
  err_ = dataset.close()
  cnt = 0
  for i = 0, ngcell -1 {
    forsec Gcell[i].all { 		        // iterate over all sections of this cell
        for (x,0) { 			        // iterate over internal nodes
            v = data_.x[cnt] 		    // f() returns the desired initial potential
            if (v>-30.) { v = -30. } 	// cut off initial potential -> no spike artifacts ...
            cnt += 1
        }
    }
  }
  for i = 0, nbcell -1 {
    forsec Bcell[i].all { 		// iterate over all sections of this cell
        for (x,0) { 			// iterate over internal nodes
            v = data_.x[cnt] 
            cnt += 1
        }
    }
  }
  for i = 0, nmcell -1 {
    forsec Mcell[i].all { // iterate over all sections of this cell
      for (x,0) { // iterate over internal nodes
        v = data_.x[cnt]
        cnt += 1
      }
    }
  }
  for i = 0, nhcell -1 {
    forsec Hcell[i].all { // iterate over all sections of this cell
      for (x,0) { // iterate over internal nodes
        v = data_.x[cnt]
        cnt += 1
      }
    }
  }
  finitialize()
}


proc init() { local dtsav, temp, secsav 
    
    // localobj ns, rs				
    // init with a int value =! 100 reset not all random number generators equally...
	
    v_init = -77.71     //-70.45
	finitialize(v_init)
	t = -1000 			// negative t step to initialize to steady state
	dtsav = dt			// original simulation step size
	dt= 10  			// larger step size	
	
    // if cvode is on, turn it off to do large fixed step
	temp= cvode.active()		
	if ( temp!=0 ) {cvode.active(0)}
	while( t < -100 ) { 
	    fadvance()
	}
	
    //restore cvode if reqd
	if (temp!=0) {cvode.active(1)}
	dt = dtsav
	t = 0
	if (cvode.active()){
		cvode.re_init()
	}else{
		fcurrent()
	}

	// restart number generators for PPStim
    t = 0
	finitialize(v_init)
	trial_old = trial

	if (debug_ ==2 ) { 
        print "number of Poisson inputs:\t",rslist.count()
    }

    if ($1 == 100) {
        for i = 0, rslist.count()-1 rslist.o(i).start()
        // for j=0, 5 print j, rslist.o(0).r.repick
        if (debug_ ==2 ) {print "reset all Poisson inputs with the correct seed"}
	} else {
        trial = trial + 1
        for i = 0,  int((rslist.count()-1)*(1-$1/100.)) rslist.o(i).start()
        if (debug_ ==2 ) {
            print "reset ",int((rslist.count()-1)*(1-$1/100.))," Poisson inputs with a different seed"
        }

        trial = trial_old 
        
        for i = int((rslist.count()-1)*(1-$1/100.)), rslist.count()-1 rslist.o(i).start()
        
        if (debug_ ==2 ) {
            print "reset ", rslist.count()-int((rslist.count()-1)*(1-$1/100.))," Poisson inputs with the correct seed"
        }	
	}

	// init noise Generators (with  seed trial_noise ...)
	trial = trial_noise
    for i = 0, rs_noiselist.count()-1 rs_noiselist.o(i).start()
    trial = trial_old
    if (debug_ ==2 ) {
        print "reset all Poisson noise inputs with the trial_noise seed"
    }
	

	VmT = new Vector()
	for i=0, cells.count-1 {
	    VmMat[i] = new Vector()
	}

	for i=0, (ngcell+nbcell +nmcell +nhcell -1) {
        Spike[i] = new Vector()                         // vector of spikes for each cell
        Spike_times[i] = new Vector()                   // vector of spikes for each cell
    }

    t = 0				
    finitialize(v_init)		// finalize at the end

    if (init_from_file_ ==1 ) { 
		if (debug_ == 2) {
            print "Read in Init State of Network"
        }
		read_custominit() 		// read in initial states from file 
	}

	frecord_init()

    // Select input pattern
    for i=PP_box_startid_, PP_box_startid_+PP_box_nr_-1 {
        PPSt[i].pp.status = 1
        PPSt[i].pp.start = PP_box_start_
        PPSt[i].pp.forcestop = PP_box_stop_
        PPSt[i].pp.nspk = PP_box_nspk_
    }
}

proc run(){
    connect_perforant_path()
	connect_granule_cells()
	connect_basket_cells()
	connect_mossy_cells()
    connect_hipp_cells() 

    if (debug_ == 2 ) {
        print "Connections drawn -> Start Simulation"
    }

	for (PP_box_startid_ = 0; PP_box_startid_ <= 12; PP_box_startid_ += 1 ) {
			saveNet()
			init(100)

            // File header voltage output file
			if (print_Vtrace == 1) { 
                sMatrix_init()  
            }      

			while (t<tstop) {
				fadvance()
				if (print_Vtrace == 1) { sMatrix() }        	// print Voltage trace
				if ((print_Raster == 1) ||  (print_template == 1))  { VecMx()   }                      // record voltage trace for all runs needed
			}

			if ((print_Raster == 1) ||  (print_template == 1))  { ConvVT2Sp() }
  			if (print_Raster == 1) {SpkMx()}                        // Output Spike Times to file!
			if (print_template == 1) {SpkMx_template()}		// Output Spike Times to file!!
			if (print_stim_==1) {write_stimIn()}
	}
	if (init_to_file_==1) {write_customstate() } // save state of network for re-init
}

run()
