
objref nclist       //  List of network connections
nclist = new List()

objref netcon
objref net_c
objref net_d
objref net_gr  // Used anywhere??
objref net_bc  // Used anywhere??
objref net_mc  // Used anywhere??
objref net_hc  // Used anywhere??

/* ============================================================================
    DECLARE CONNECTIVITY VECTORS AND PSEUDORANDOM NUMBER GENERATORS 

    NOTEs: 
        - Vectors defines vectors for each "pre2post" pair, 
        - Vector length is same as number of post cells fills with 0
        - RNGs from Santhakumar et al. (2005) begin with `rd`
        - RNGs from Yim et al. (2015) begin with `rnd`   

    TODOs: 
        - [ ] Place object declarations more locally to where they are used
============================================================================ */

// GC -> {GC, BC, MC, HC} 
objref vgc2gc, vgc2bc, vgc2mc, vgc2hc
objref rdgc2gc, rdgc2bc, rdgc2mc, rdgc2hc
vgc2gc = new Vector(ngcell, 0)
vgc2bc = new Vector(nbcell, 0)
vgc2mc = new Vector(nmcell, 0)
vgc2hc = new Vector(nhcell, 0)

rdgc2gc = new Random(rseed)	
proc new_rdgc2gc() {rdgc2gc.discunif(-50, 50)}
new_rdgc2gc()

rdgc2bc = new Random(rseed) 
proc new_rdgc2bc() {rdgc2bc.discunif(-1,1)}	
new_rdgc2bc()

rdgc2mc = new Random(rseed)
proc new_rdgc2mc() {rdgc2mc.discunif(0,2)}
new_rdgc2mc()

rdgc2hc = new Random(rseed)
proc new_rdgc2hc() {rdgc2hc.discunif(-2,2)}
new_rdgc2hc()

// BC -> {GC, BC, MC}
objref vbc2gc, vbc2bc, vbc2mc
objref rdbc2gc, rdbc2bc, rdbc2mc
vbc2gc = new Vector(ngcell, 0)
vbc2bc = new Vector(nbcell, 0)
vbc2mc = new Vector(nmcell, 0)

rdbc2gc = new Random(rseed)
proc new_rdbc2gc() {rdbc2gc.discunif(-70, 70)}
new_rdbc2gc()

rdbc2bc = new Random(rseed)
proc new_rdbc2bc() {rdbc2bc.discunif(-1, 1)}
new_rdbc2bc()

rdbc2mc = new Random(rseed)
proc new_rdbc2mc() {rdbc2mc.discunif(-3, 3)}
new_rdbc2mc()

// MC -> {GC, BC, MC, HC}
objref vmc2gc, vmc2bc, vmc2mc, vmc2hc
objref rdmc2gc1, rdmc2gc2, rdmc2bc, rdmc2mc, rdmc2mc1, rdmc2hc
vmc2gc = new Vector(ngcell, 0)
vmc2bc = new Vector(nbcell, 0)
vmc2mc = new Vector(nmcell, 0)
vmc2hc = new Vector(nhcell, 0)

rdmc2gc1 = new Random(rseed)
proc new_rdmc2gc1() {rdmc2gc1.discunif(25, 175)}
new_rdmc2gc1()

rdmc2gc2 = new Random(rseed)			
proc new_rdmc2gc2() {rdmc2gc2.discunif(-175, -25)}
new_rdmc2gc2()

rdmc2bc = new Random(rseed)			
proc new_rdmc2bc() {rdmc2bc.discunif(-3,3)}
new_rdmc2bc()

rdmc2mc = new Random(rseed)			
proc new_rdmc2mc() {rdmc2mc.discunif(ngcell+nbcell, ngcell+nbcell+nmcell-1)}
new_rdmc2mc()

rdmc2mc1 = new Random(rseed)			
proc new_rdmc2mc1() {rdmc2mc1.discunif(-3, 3)}
new_rdmc2mc1()

rdmc2hc = new Random(rseed)			
proc new_rdmc2hc() {rdmc2hc.discunif(-2, 2)}
new_rdmc2hc()

// HC -> {GC, BC, MC}
objref vhc2gc, vhc2bc, vhc2mc
objref rdhc2gc, rdhc2bc, rdhc2mc
vhc2gc = new Vector(ngcell, 0)
vhc2bc = new Vector(nbcell, 0)
vhc2mc = new Vector(nmcell, 0)

rdhc2gc = new Random(rseed)			
proc new_rdhc2gc() {rdhc2gc.discunif(-130, 130)}
new_rdhc2gc()

rdhc2bc = new Random(rseed)			
proc new_rdhc2bc() {rdhc2bc.discunif(-2, 2)}
new_rdhc2bc()

rdhc2mc = new Random(rseed)			
proc new_rdhc2mc() {rdhc2mc.discunif(-2, 2)}
new_rdhc2mc()

// Object to identify MC's to kill (as in Santhakumar et al. 2005)
objref killMC
objref deadMC
killMC = new Vector(8, 0)

deadMC = new Random(rseed)		
proc new_deadMC() { deadMC.discunif(ngcell+nbcell, ngcell+nbcell+nmcell-1) }
new_deadMC()

// PP -> {GC, BC, HC}
//  CONNECTIVITY VECTORS ARE INSTANTIATED LATER!
objref pp2gc, pp2bc, pp2hc
objref rnd_pp2gc, rnd_pp2bc, rnd_pp2hc

rnd_pp2gc  = new Random(rseed)    
proc new_rnd_pp2gc() {rnd_pp2gc.discunif(0,npp-1)}
new_rnd_pp2gc()

rnd_pp2bc  = new Random(rseed)
proc new_rnd_pp2bc() {rnd_pp2bc.discunif(0,npp-1)}
new_rnd_pp2bc()

rnd_pp2hc  = new Random(rseed)
proc new_rnd_pp2hc() {rnd_pp2hc.discunif(0,npp-1)}
new_rnd_pp2hc()

// RNGs FOR DENDRITIC LOCATION OF SYNAPSES
objref rdsynb, rdsyna 

rdsyna = new Random(rseed)
proc new_rdsyna() {rdsyna.discunif(0, 1)}
new_rdsyna()

rdsynb = new Random(rseed)
proc new_rdsynb() {rdsynb.discunif(0, 3)}
new_rdsynb()

/* ============================================================================
    INITIATE NETWORK 
============================================================================ */
for i = 0, ngcell-1 {cell_append(Gcell[i])} 	// cells 0-499 GCs
for i = 0, nbcell-1 {cell_append(Bcell[i])} 	// cells 500-505 BC
for i = 0, nmcell-1 {cell_append(Mcell[i])} 	// cells 506-520 MC
for i = 0, nhcell-1 {cell_append(Hcell[i])} 	// cells 521-526 HC
for i = 0, npp-1 {cell_append(PPSt[i])}		    // 527 - xxx PP artificial cell
for i = 0, npp-1 {cell_append(PPSt_noise[i])}   // 527 - xxx PP artificial cell for noise


/* ============================================================================
    CONNECTIVITY RELATED FUNCTIONS 
============================================================================ */
func nc_append() {	
        // neuron connect $1 with $2.pre_list.object($3), weight $4, delay $5, threshold $6
        // connects:
        // cells.object($1)                             with
        // $o1 = cells.object($2).pre_list.object($3)   and
        // returns:
        // netcon = $o2

	if ($3 >= 0 )	{
        //  connect_pre is function in the respective cell definition
		cells.object($1).connect_pre(cells.object($2).pre_list.object($3),netcon)	
		netcon.weight = $4	netcon.delay = $5	netcon.threshold = $6
	} 
	nclist.append(netcon)
	return nclist.count-1
}

func nc_append_rec() { // neuron connect $1 with $2.pre_list.object($3), weight $4, delay $5, threshold $6
    // connects:
    // cells.object($1)                             with
    // $o1 = cells.object($2).pre_list.object($3)   and
    // returns:
    // netcon = $o2
    // record events to $o7

    if ($3 >= 0 )   {
        //  connect_pre is function in the respective cell definition
        cells.object($1).connect_pre(cells.object($2).pre_list.object($3),netcon)       
        netcon.weight = $4
        netcon.delay = $5
        netcon.threshold = $6
        netcon.record($o7)
    }
    nclist.append(netcon)
    return nclist.count-1
}


func is_connected() {local i, c
    // To check for preexisting connections between randomly selected cells
    // to avoid multiple contacts between same 2 cells
	c=0
	for i=0, nclist.count-1 {
		net_c = nclist.object(i)
		if (($o1 == net_c.postcell())  && ($o2 == net_c.precell())) {c=1}
	}
	return c
}
    

/* ============================================================================
    CONNECTION PROCEDURES  

connect_pp_to_gc()       : Connects perforant path neurons to granule cells
connect_pp_to_bc()       : Connects perforant path neurons to basket cells
connect_pp_to_hipp()     : Connects perforant path neurons to HIPP cells
connect_perforant_path() : Initializes the perforant path connections
connect_granule_cells()  : Initializes granule cell connections
connect_basket_cells()   : Initializes basket cell connections
connect_mossy_cells()    : Initializes mossy cell connections
connect_hipp_cells()    : Initializes HIPP cell connections
============================================================================ */

objref pprec
proc connect_pp_to_gc() { local i, j
    // Create vector that marks PP neurons that already project to a GC
    pprec =  new Vector(npp, 0) 

    // Make connections for each individual GC
    for i=0, ngcell-1 {
        // Re-initialize connectivity vector to prevent multiple stimulation 
        // connections from the same PP cell
        pp2gc = new Vector(npp, 0)	

        // Each GC receives input from random set of 20% of PP neurons
        // [ TODO ] - ALLOW TO HAVE 20% CHANGED TO DIFFERENT VALUES
        for nr_conn = 0, int(npp/5.) - 1 {
            // Pick a random PP cell to connect to the GC
            // Repeat until j is a PP cell that is not yet connected
            // Then mark j as connected so it is not chosen again 
            j = rnd_pp2gc.repick()
            while (pp2gc.x[j] == 1)	{ j = rnd_pp2gc.repick() }
            pp2gc.x[j] = 1
            
            if ((print_stim_==1) && (i<npp)) {
                if (pprec.x[j] == 0) {
                    // record input sequence to first neuron for debug purpose only....
                    nc_append_rec(j+ngcell+nbcell+nmcell+nhcell, i, 0, 2e-2*scale_PP_strength/100., 3, 10, vec_stim[j]) 
                    pprec.x[j] = 1
                } else {
                    // record input sequence to first neuron for debug purpose only....
                    nc_append(j+ngcell+nbcell+nmcell+nhcell, i, 0, 2e-2*scale_PP_strength/100., 3, 10)
                }
            } else {
                // connect PP to GC[j],syn[0],wt,del,threshold   <AH> NOTE both synapses are equal, ie. weight delay (except position) not important
                nc_append(j+ngcell+nbcell+nmcell+nhcell, i, 0, 2e-2*scale_PP_strength/100., 3, 10)
            }
        }
        
        // Print debugging message 
        if (debug_ == 3) {
            print "\nGC: ",i
            for ii=0,pp2gc.size()-1 { printf ("%d, ",pp2gc.x[ii]) }
        }
    }
}

proc connect_pp_to_bc() { local i,j 
    // Only proceed if there are PP to BC connections
    if (scale_PP2BC_strength != 0) {
        for i=ngcell, ngcell+nbcell-1 {
            pp2bc = new Vector(npp, 0)

            // Each BC receives input from random set of 20% of PP neurons
            // [ TODO ] - ALLOW TO HAVE 20% CHANGED TO DIFFERENT VALUES
            for nr_conn = 0, int(npp/5.)-1 {
                j = rnd_pp2bc.repick()
                while (pp2bc.x[j] == 1)  { j = rnd_pp2bc.repick() }
                pp2bc.x[j] = 1
                
                // connect PP to BC[j],syn[0],wt,del,threshold   <AH> NOTE both synapses are equal
                nc_append(j+ngcell+nbcell+nmcell+nhcell, i, 0, 1e-2*scale_PP_strength/100.*scale_PP2BC_strength/100., 3, 10)
            }

            // Print debugging message 
            if (debug_ == 3) {
                print "\nBC: ",i
                for ii=0,pp2bc.size()-1{ printf ("%d, ",pp2gc.x[ii])}
            }
        }
    }
}

proc connect_pp_to_hipp() { local i,j 
    if (scale_PP2HC_strength != 0) {
        if (debug_ == 2) { 
            print "PP -> HIPP (input to two HIPP cells as in Myers and Scharfman 2009)"
        }
        
        for i=0, nhcell-1 {
            pp2hc = new Vector(npp, 0)

            // Each HIPP receives input from random set of 20% of PP neurons
            // [ TODO ] - ALLOW TO HAVE 20% CHANGED TO DIFFERENT VALUES
            for nr_conn = 0, int(npp/5.)-1 {
                j = rnd_pp2hc.repick()
                while (pp2hc.x[j] == 1) { j = rnd_pp2hc.repick() }
                pp2hc.x[j] = 1
                
                // used here synaptic strength of GC->HIPP / connections PP-> HIPP not in Santhakumar 2005
                nc_append(j+ngcell+nbcell+nmcell+nhcell, i+ngcell+nbcell+nmcell, 0, 0.5e-3*scale_PP_strength/100.*scale_PP2HC_strength/100., 3, 10)

            }
            if (debug_ == 3) {
                print "\nHIPP: ",i
                for ii=0,pp2bc.size()-1{ printf ("%d, ",pp2hc.x[ii])}
            }
        }
        if (debug_ == 3) { print "PP -> HIPP -DONE-" }
    }
}

proc connect_perforant_path() {
    if (debug_ == 2 ) { 
        print "Preforant Path synaptic connections"
        print "Correlated input from 100 EC Layer 2 cells"
    }

    connect_pp_to_gc()
    connect_pp_to_bc()
    connect_pp_to_hipp()
}

proc connect_granule_cells() { local i,j

    if (debug_ == 2 ) { print "Granule Cell post synaptic connections"}
    if (debug_ == 0) { print "n_sprout_ = ",n_sprout_ }
    if (p_sprouted_>0 && debug_ == 2) {print "NOTE: we have sprouting connections..."}

    for  i=0, ngcell-1 {

        // CONNECT GC'S TO BC'S
        for j=0, 0 {	
            // Which lamella is GC[i] in wrt basket cells 
            // Note: one basket cell per lamella
            // [ TODO ] - Allow for more than one BC per lamella
            if (i < ngcell/nbcell) { a=0 }
            if ((i > ngcell/nbcell-1) && (i < ngcell*2/nbcell)) { a=1 }
            if ((i > ngcell*2/nbcell-1) && (i < ngcell*3/nbcell)) { a=2 }
            if ((i > ngcell*3/nbcell-1) && (i < ngcell*4/nbcell)) { a=3 }
            if ((i > ngcell*4/nbcell-1) && (i < ngcell*5/nbcell)) { a=4 }
            if ((i > ngcell*5/nbcell-1) && (i < ngcell)) { a=5}

            // Randomly pick location of post synaptic Bcell from distribution [-1:1]
            Gauz3 = rdgc2bc.repick()

            // Determine appropriate post syn BC
            if (a+Gauz3 > nbcell-1) { npost = a+Gauz3-nbcell } 		
            if (a+Gauz3 < 0) { npost = a+Gauz3+nbcell } 
            if ((a+Gauz3 > -1) && (a+Gauz3 < nbcell)) {npost = a+Gauz3}

            // randomly pick the dendrite to connect to from [0:3] ( i.e. // randomize among 4 dendrites )
            dbr = rdsynb.repick() 						
            if (debug_ == 1 ) { 
                print "GC \t",i,"\t to BC\t\t",npost, a
            }

            // check to make sure that post syn BC does not get more than 90 GC synapses
            // [ TODO ] - ALLOW FOR DIFFERENT NUMBER OF MAX SYNAPSES
            if (vgc2bc.x[npost] < 90) { 					
                // connect GC[i] to BC[j],syn[2]+dendritic_var,wt,del,threshold
                nc_append(i, ngcell+npost, dbr+2, 4.7e-3*scale_GC2BC_strength/100., .8, 10)
                
                if (debug_ == 0 ) { 
                    print "GC \t",i,"\t to BC\t\t",npost,"\t",dbr+2 
                }
                
                // increment the no of synapses to the post cell
                vgc2bc.x[npost]  +=1

            } else {
                j -= 1	
                if (debug_ == 1 ) {print "nogc2bc"}
            } // for connection that is not made reconnect axon to another cell
        }

        // CONNECT GC'S TO MC'S
        for j=0, 0 {
            // Based on the lamellar distribution of the GCs to MCs - 500 GCs were divided into 5 groups, 3 MCs were distributed in each lamella
            // print "Based on the lamellar distribution of the GCs to MCs..."
            // [ TODO ] - Allow for different number of MC's per lamella
            if (i < ngcell/5) { a=0}
            if ((i > ngcell/5-1) && (i < ngcell*2/5)) { a=1}
            if ((i > ngcell*2/5-1) && (i < ngcell*3/5)) { a=2}
            if ((i > ngcell*3/5-1) && (i < ngcell*4/5)) { a=3}
            if ((i > ngcell*4/5-1) && (i < ngcell)) { a=4}
            b=a*3						// from [0:12]
            npost = rdgc2mc.repick()	// from [0:2]
            dbr = rdsynb.repick()		// from [0:2]


            // [ TODO ] - ALLOW FOR DIFFERENT NUMBER OF MAX SYNAPSES
            if (vgc2mc.x[npost+b] < 38){
                nc_append(i, ngcell+nbcell+npost+b, dbr+4, 0.2e-3, 1.5, 10)
                
                if (debug_ == 1 ) {
                    print "GC \t",i,"\t to MC\t\t", npost+b, "\t", dbr+4
                }

                vgc2mc.x[npost+b] +=1
            } else {
                j -= 1
                if (debug_ == 1 ) {
                    print "nogc2mc"
                }
            }
        }


        for j=0, 2 {
            // <AH> comment added:
            // Based on the lamellar distribution of the GCs to HIPPs - 500 GCs were divided into 6 groups
            if (i < ngcell/6) { a=0}
            if ((i > ngcell/6-1) && (i < ngcell*2/6)) { a=1}
            if ((i > ngcell*2/6-1) && (i < ngcell*3/6)) { a=2}
            if ((i > ngcell*3/6-1) && (i < ngcell*4/6)) { a=3}
            if ((i > ngcell*4/6-1) && (i < ngcell*5/6)) { a=4}
            if ((i > ngcell*5/6-1) && (i < ngcell)) { a=5}

            Gauz3 = rdgc2hc.repick()	
            if (a+Gauz3 > nhcell-1) { npost = a+Gauz3-nhcell }
            if (a+Gauz3 < 0) { npost = a+Gauz3+nhcell } 
            if ((a+Gauz3 > -1) && (a+Gauz3 < nhcell)) { npost = a+Gauz3 }
            
            dbr = rdsynb.repick()
            if ((is_connected(HIPPCell[npost], GranuleCell[i]) == 0) && (vgc2hc.x[npost] < 275)) {
                nc_append(i, ngcell+nbcell+nmcell+npost, dbr, 0.5e-3, 1.5, 10)
                if (debug_ == 0 ) {
                    print "GC \t",i,"\t to HC\t\t",npost, "\t", dbr
                }
                vgc2hc.x[npost] +=1
            } else {
                j -= 1
            }
        }

        // GCs -> GCs
        // NOTE: THIS IS FOR SPROUTED SYNAPSES
        // NOTE: 100% Sprouting = 100 new synapses! (compare p. 443 in Santhakumar paper)
        n_sprout_ =  p_sprouted_ - 1				

        // 9 in original file // each GC is recurrent connected to 10 GC  
        // (i.e. 10/500 => p = 0.02) but sprouting is diff different -> see above
        for j=0, n_sprout_  {
            Gauz3 = rdgc2gc.repick()
            if (i+Gauz3 > 499) { npost = i+Gauz3-500 }
            if (i+Gauz3 < 0) { npost = i+Gauz3+500 } 
            if ((i+Gauz3 > -1) && (i+Gauz3 < 500)) { npost = i+Gauz3 }

            dbr = rdsyna.repick()				// [0:1]
            if ((is_connected(GranuleCell[npost], GranuleCell[i]) == 0) && (vgc2gc.x[npost] < (n_sprout_*1.5+2) )) {	// if is connected AND not more than 14 incoming connections...
                                                                //  (original file < 15) (assume 1.5 times average connections for upper limit...)
                nc_append(i, npost, dbr+7, 2e-3, .8, 10)  							// Gcell[3] to Bcell[1]
                //	print npost, dbr+8					
                if (debug_ == 0 ) {print "GC \t",i,"\t to GC\t\t",npost, "\t", dbr+7}
                vgc2gc.x[npost] +=1
            } else {
                j -= 1	
                if (debug_ == 0) {print "gc2gc"}
            }
        }
    }

    if (print_GC_sprouting_input_ == 1) {
        // objref distri_gc_input_
        // distri_gc_input_ = new Vector()
        max_gc_input_  = 0 
        if (debug_ ==2) { print "Calculate GC-GC Input Distribution"}

        for zz = 0, int(n_sprout_*1.5+2)  {distri_gc_input_.append(0)}
        for npost=0,ngcell-1 {
            distri_gc_input_.x[vgc2gc.x[npost]]+=1
            if (vgc2gc.x[npost]>max_gc_input_) { max_gc_input_ = vgc2gc.x[npost]}		// find max input number 
        }
        for zz = 0, int(n_sprout_*1.5+2)  {print zz,"\t",distri_gc_input_.x[zz]}
        print "maximum input number is:\t",max_gc_input_
    }	
}

proc connect_basket_cells() { local i,j 
    if (debug_ ==2) {
        print "Basket Cell post synaptic connections ... "
    }

    for  i=0, nbcell-1 {
        // BC -> GC 
        // [ TODO ] - Allow for different lamella sizes
        for j=0, 99 {
            Gauz3 = rdbc2gc.repick()    // [-70:70]
            if (debug_ == 1 ) {print Gauz3}
            if (i*83+41+Gauz3 > 499) {npost = i*83+41+Gauz3-500 }
            if (i*83+41+Gauz3 < 0) {npost = i*83+41+Gauz3+500} 
            if ((i*83+41+Gauz3 > -1) && (i*83+41+Gauz3 < 500)) {npost = i*83+41+Gauz3}
            if (debug_ == 1 ) {print i, npost}
            if (nbcell != 6) {max_conn = 4} else {max_conn = 2}								// if not original setup use more spread...
            if ((is_connected(GranuleCell[npost], BasketCell[i]) == 0) && (vbc2gc.x[npost] < max_conn)) {	// change < 2 to < 4
                nc_append(i+ngcell, npost, 6, 1.6e-3*scale_BC2GC_strength/100, .85, -10)  
                vbc2gc.x[npost] +=1
                if (debug_ == 1 ) { print i, npost, 6 }
            } else {
                j -= 1
                if (debug_ == 1 ) {print "BC2GC"}
            }
        }

        // BC -> BC
        for j=0, 1 {
            Gauz3  = rdbc2bc.repick()		// [-1,0,1] (postsyn spread around single id...)
            //print Gauz3
            if (i+Gauz3 > nbcell-1) {npost = i+Gauz3-nbcell }	 // periodic boundary conditions 
            if (i+Gauz3 < 0) {npost = i+Gauz3+nbcell} 
            if ((i+Gauz3 >-1) && (i+Gauz3 < nbcell)) {npost = i+Gauz3}
            dbr = rdsyna.repick()		// [0:1]
            if (nbcell != 6) {max_conn = 4} else {max_conn = 3} 
            if ((is_connected(BasketCell[npost], BasketCell[i]) == 0) && (vbc2bc.x[npost] < max_conn)) {			// change < 3 to < 4
                nc_append(i+ngcell, npost+ngcell, dbr+8, 7.6e-3, .8, -10)  
                if (debug_ == 1 ) {print npost, dbr+8}
                vbc2bc.x[npost] +=1
            } else {
                j -= 1	
                if (debug_ == 1 ) {print "bc2bc"}
            }
        }

        // BC -> MC
        for j=0, 2 {
            Gauz3 = rdbc2mc.repick()				// [-3:3]
            if (i*2+2+Gauz3 > 14) {npost = i*2+2+Gauz3-15 }
            if (i*2+2+Gauz3 < 0) {npost = i*2+2+Gauz3+15} 
            if ((i*2+2+Gauz3 >-1) && (i*2+2+Gauz3 < 15)) {npost = i*2+2+Gauz3}
        //	if ((is_connected(MossyCell[npost], BasketCell[i]) == 0) && (vbc2mc.x[npost] < 3) && (killMC.contains(ngcell+nbcell+npost) == 0)) {	// use if killing MC
            if (nbcell != 6) {max_conn = 4} else {max_conn = 3} 
            if ((is_connected(MossyCell[npost], BasketCell[i]) == 0) && (vbc2mc.x[npost] < max_conn)) {			// change < 3 to < 4
            nc_append(i+ngcell, npost+ngcell+nbcell, 12, 1.5e-3, 1.5, -10)  // Gcell[3] to Bcell[1]
            if (debug_ == 1 ) {print npost, 12}
            vbc2mc.x[npost] +=1
            } else {	
                j -= 1	
                if (debug_ == 1 ) {print "bc2mc"}
            }
        //	if (killMC.contains(ngcell+nbcell+npost) == 1) {j +=1 if (debug_ == 1 ) {print "dead MC"}}	// use if killing MC
        }
    }
}


proc connect_mossy_cells() {local i,j 
    if (debug_ ==2 ) { 
        print "Mossy Cell post synaptic connections"
    }

    for  i=0, nmcell-1 {
         
        //if (killMC.contains(ngcell+nbcell+i) == 0) 	// use if killing MC
        if (i < 3) { y=0 }
        if ((i > 2) && (i < 6)) { y=1 }
        if ((i > 5) && (i < 9)) { y=2 }
        if ((i > 8) && (i < 12)) { y=3 }
        if ((i > 11) && (i < 15)) { y=4 }
        
        // MC -> GC1
        for j=0, 99 {
            Gauz1 = rdmc2gc1.repick()		// [25:175]
            if (i*33+17+Gauz1 > 499) {
                npost1 = i*33+17+Gauz1-500
            } else {
                npost1 =i*33+17+Gauz1
            }
            
            dbr = rdsyna.repick()			// [0:1]
            if ((is_connected(GranuleCell[npost1], MossyCell[i]) == 0) && (vmc2gc.x[npost1] < 7))  {
                nc_append(i+ngcell+nbcell, npost1, dbr+2, 0.3e-3*scale_MC2GC_strength/100., 3, 10)
                vmc2gc.x[npost1] +=1
            } else { 
                j -= 1	
            } 
        }

        // MC -> GC2
        for j=0, 99 {
            Gauz2 = rdmc2gc2.repick()		// [-175:25]
            if (i*33+17+Gauz2 < 0) {
                npost2 =i*33+17+Gauz2+500
            } else {npost2 =i*33+17+Gauz2}
                dbr = rdsyna.repick()			// [0:1]
            if ((is_connected(GranuleCell[npost2], MossyCell[i]) == 0) && (vmc2gc.x[npost2] < 7))  {
                nc_append(i+ngcell+nbcell, npost2, dbr+2, 0.3e-3*scale_MC2GC_strength/100., 3, 10)  // Gcell[3] to Bcell[1]
                vmc2gc.x[npost2] +=1
            } else { 
                j -= 1	 
            }
        }


        // MC -> BC
        for j=0, 0 {
            Gauz3 = rdmc2bc.repick()						    // Gauz3 = [-3:3]	
            if (y+Gauz3 > nbcell-1) {npost = y+Gauz3-nbcell}    // y     = [0:4] 	=> y+Gaus3 = [-3:7]
            if (y+Gauz3 < 0) {npost = y+Gauz3+nbcell} 
            if ((y+Gauz3 > -1) && (y+Gauz3 < nbcell)) {npost = y+Gauz3}
            dbr = rdsyna.repick()
            if ((vmc2bc.x[npost] < 4) && (Gauz3 !=0)) {
                nc_append(i+ngcell+nbcell, ngcell+npost, dbr+6, 0.3e-3, 3, 10)  // Gcell[3] to Bcell[1]
                vmc2bc.x[npost] += 1
            } else { 
                j -= 1	 
            } 
        }


        // MC -> MC 
        for j=0, 2 {
            Gauz3 = rdmc2mc1.repick()		//[-3:3]
            if (i+Gauz3 > 14) {npost = i+Gauz3-15 }
            if (i+Gauz3 < 0) {npost = i+Gauz3+15} 
            if ((i+Gauz3 >-1) && (i+Gauz3 < 15)) {npost = i+Gauz3}
            dbr = rdsynb.repick()
            //	if ((is_connected(MossyCell[npost], MossyCell[i]) == 0) && (vmc2mc.x[npost] < 4) && (Gauz3 != 0) && (killMC.contains(ngcell+nbcell+npost) == 0))  	// use if killing MC
            if ((is_connected(MossyCell[npost], MossyCell[i]) == 0) && (vmc2mc.x[npost] < 4) && (Gauz3 != 0))  {
                nc_append(i+ngcell+nbcell, npost+ngcell+nbcell, dbr+8, 0.5e-3, 2, 10)  // Gcell[3] to Bcell[1]
                //	print npost, dbr+8
                vmc2mc.x[npost] +=1
            } else { 
                j -= 1	
            }
            // 	if (killMC.contains(ngcell+nbcell+npost) == 1){ j += 1 print "dead MC"}	// use if killing MC
        }


        // MC -> HC
        for j=0, 1 {
            Gauz3 = rdmc2hc.repick()			// [-2:2]
            if (y+Gauz3 > nhcell-1) {npost = y+Gauz3-nhcell}							// changed code here to allow > 6 HCells
            if (y+Gauz3 < 0) {npost = y+Gauz3+nhcell} 
            if ((y+Gauz3 > -1) && (y+Gauz3 < nhcell)) {npost = y+Gauz3}
            dbr = rdsynb.repick()
            if ((is_connected(HIPPCell[npost], MossyCell[i]) == 0) && (vmc2hc.x[npost] < 7) && (Gauz3 != 0))  {
                nc_append(i+ngcell+nbcell, ngcell+nbcell+nmcell+npost, dbr+4, 0.2e-3, 3, 10)  // Gcell[3] to Bcell[1]
                //	print npost, dbr+4
                vmc2hc.x[npost] +=1
            } else {
                j -= 1	
            }
        }
    }
}


proc connect_hipp_cells() {local i,j
    if (debug_ ==2 ) { print "HIPP Cell post synaptic connections"}
    for  i=0, nhcell-1 {

        // HC -> GC
        for j=0, 159 {											// NOTE number of connections explicitly coded here!
            Gauz3 = rdhc2gc.repick()									// [-130:130]
            //print Gauz3
            if (i*83+41+Gauz3 > 499) {npost = i*83+41+Gauz3-500 }						// NOTE: 500 is explicitly coded here!
            if (i*83+41+Gauz3 < 0) {npost = i*83+41+Gauz3+500} 
            if ((i*83+41+Gauz3 > -1) && (i*83+41+Gauz3 < 500)) {npost = i*83+41+Gauz3}
            //print npost
            dbr = rdsyna.repick()
            if (nhcell != 6) {max_conn = 5} else {max_conn = 3}
            if ((is_connected(GranuleCell[npost], HIPPCell[i]) == 0) && (vhc2gc.x[npost] < max_conn))  {		// NOTE < 3 coded explicitly here! -> change to 5
                nc_append(i+ngcell+nbcell+nmcell, npost, dbr+4, 0.5e-3*scale_HC2GC_strength/100., 1.6, 10)  			// Hcell to Gcell
                vhc2gc.x[npost] +=1
                if (debug_ == 1 ) {print i, npost, dbr+4}
            } else {
                j -= 1	
                if (debug_ == 1 ) {print "HC2GC"}
            }
        }

        // HC -> BC
        for j=0, 3 {
            Gauz3 = rdhc2bc.repick()									// [-2:2]
            if (i+Gauz3 > nbcell-1) {npost = i+Gauz3-nbcell}
            if (i+Gauz3 < 0) {npost = i+Gauz3+nbcell} 
            if ((i+Gauz3 > -1) && (i+Gauz3 < nbcell)) {npost = i+Gauz3}
            dbr = rdsyna.repick()
            if ((is_connected(BasketCell[npost], HIPPCell[i]) == 0) && (vhc2bc.x[npost] < 5))  {		// NOTE < 5 coded explicitly here!
                nc_append(i+ngcell+nbcell+nmcell, npost+ngcell, dbr+10, 0.5e-3, 1.6, 10)  		// Hcell to Bcell
                if (debug_ == 1 ) {print npost, dbr+10}
                vhc2bc.x[npost] += 1
            } else {
                j -= 1	
                if (debug_ == 1 ) {print "HC2BC"}
            }
        }

        // HC -> MC
        for j=0, 3 {							
            Gauz3 = rdhc2mc.repick()									// [-2:2]
            //print Gauz3
            if (i*2+2+Gauz3 > 14) {npost = i*2+2+Gauz3-15 }
            if (i*2+2+Gauz3 < 0) {npost = i*2+2+Gauz3+15} 
            if ((i*2+2+Gauz3 >-1) && (i*2+2+Gauz3 < 15)) {npost = i*2+2+Gauz3}
            //print npost
            dbr = rdsynb.repick()
            //	  if ((is_connected(MossyCell[npost], HIPPCell[i]) == 0) && (vhc2mc.x[npost] < 2) && (killMC.contains(ngcell+nbcell+npost) == 0))  	//use if killing MC
                if (nhcell != 6) {max_conn = 4} else {max_conn = 2}
            if ((is_connected(MossyCell[npost], HIPPCell[i]) == 0) && (vhc2mc.x[npost] < max_conn))  {		// NOTE < 2 coded explicitly here!!  => changed to 4 
                nc_append(i+ngcell+nbcell+nmcell, npost+ngcell+nbcell, dbr+13, 1.5e-3, 1, 10)  		// Hcell to Mcell
                //if (debug_ == 1 ) {print npost, dbr+13}
                vhc2mc.x[npost] += 1
            } else {	
                j -= 1	
                if (debug_ == 1 ) {print "HC2MC"}
            }
            //  if (killMC.contains(ngcell+nbcell+npost) == 1){ j += 1 print "dead MC"} 			//use if killing MC
        }
    }
}