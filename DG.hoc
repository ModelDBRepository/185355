/* DENTATE GYRUS NETWORK TEMPLATE 
    TODO: 
        - Consider allowing seed change via argument to init() 
        - Change the scaling to not be from 0-100 but from 0-1
        - Account for different networks in file output names 
        - Implement PP stimulation of MCs
        - Might rename `global_seed` 

        - Where to put the following?
            // INITIALIZE CVODE 
            objref cvode
            cvode = new CVode()
            using_cvode_ = 1
            debug_ 		 = 2   // print output (everything: debug==1; some: debug==0 ) 

        - Where to put the following?
            // for debug purpose only...
            objref netcon, nil
            objref vec_debug_
            objref PP_init_rnd		// random number generator to select an PP stimulus site..
            objref nslist, rslist, rs_noiselist
            objref ns, rs

        - Update docstrings on nc_append_rec() and nc_append()
        - Clean the following procs/funcs, which were not changed much from Yim et al.: 
            - onnect_pp_to_gc()
            - connect_pp_to_bc()
            - connect_pp_to_hipp()


        - Remove references to the following: 
            init_from_file_ = 0		// read in initial potential of all cells/compartments from file 
            init_to_file_ 	= 0		// save potential of all cells/compartments to file @ end of run (to be used for init the network later again)
*/

// Pre-load cell templates
err_ = load_file("GC.hoc")
err_ = load_file("BC.hoc")
err_ = load_file("MC.hoc")
err_ = load_file("HIPP.hoc")
err_ = load_file("PP.hoc")

begintemplate DentateGyrus
    // Simulation related declarations
    //      Random number generators 
    objref rdgc2gc, rdgc2bc, rdgc2mc, rdgc2hc 
    objref rdbc2gc, rdbc2bc, rdbc2mc
    objref rdmc2gc1, rdmc2gc2, rdmc2bc, rdmc2mc, rdmc2mc1, rdmc2hc
    objref rdhc2gc, rdhc2bc, rdhc2mc
    objref rnd_pp2gc, rnd_pp2bc, rnd_pp2hc
    objref rdsynb, rdsyna 

    // Data management related declarations 
    objref Spike[726], Spike_times[726], dfile

    // Declarations related to debugging 
    objref vec_stim[100], vec_stim_noise[100]
    objref distri_gc_input_

    // Network related declarations
    public ngcell, nbcell, nmcell, nhcell, npp, nmcell_per_lamella, ntotal
    public p_sprouted_
    public cells, nclist
    objref cells , Gcell[500], Bcell[6], Mcell[15], Hcell[6]
    objref PPSt[100], PPSt_noise[100]
    objref nclist, netcon
    objref vgc2gc, vgc2bc, vgc2mc, vgc2hc
    objref vbc2gc, vbc2bc, vbc2mc
    objref vmc2gc, vmc2bc, vmc2mc, vmc2hc
    objref vhc2gc, vhc2bc, vhc2mc
    objref pp2gc, pp2bc, pp2hc

    proc init() {
        /* Initialization of the DentateGyrus object
        
        Arguments: 
            $1 : int : Which figure you are trying to generate data for
            $2 : int : Random state (global RNG seed)
        */
        fig = $1
        random_state = $2

        // Simulation and data storage parameters
        set_simulation_parameters(random_state)
        set_data_management_params()

        // Set parameters related to network
        set_neuron_population_sizes()
        set_perforant_path_input_params()
        set_connectivity_params()

        // Initialize pseudorandom number generators
        set_pseudorandom_number_generators()

        // Parameter modifications
        yim_param_modifications(fig)

        // Create network
        make_cells()
        make_connections()

    }

    proc set_simulation_parameters() {
        /* Sets parameters for numerical aspects of the simulation 
        
        Arguments: 
            $1 : int :  Global RNG seed
        */
        dt = 0.1            // simulation time step [ms]
        tstop = 200         // total simulation time [ms]
        trial = $1          // trialnumber = seed of simulation
        trial_noise = 1     // seed for noise to PP
        rseed  = $1         // pseudorandom number generator seed
        debug_ = 2

    }


    proc set_pseudorandom_number_generators(){
        /* Create the pseudorandom number generators for the network 

        Notes: 
            - ranstream.hoc must be loaded after `set_simulation_parameters` 
                because it depends on `trial` being set. 

        TODO: 
            - Pass argument to ranstream rather than requiring external
        */
        // Load ranstream
        err_ = load_file("ranstream.hoc")

        // Create RNGs for network connectivity establishment
        //  GC -> {GC, BC, MC, HC} 
        rdgc2gc = new Random(rseed)	
        rdgc2bc = new Random(rseed) 
        rdgc2mc = new Random(rseed)
        rdgc2hc = new Random(rseed)
        rdgc2gc.discunif(-50, 50)
        rdgc2bc.discunif(-1,1)
        rdgc2mc.discunif(0,2)
        rdgc2hc.discunif(-2,2)

        // BC -> {GC, BC, MC}
        rdbc2gc = new Random(rseed)
        rdbc2bc = new Random(rseed)
        rdbc2mc = new Random(rseed)
        rdbc2gc.discunif(-70, 70)
        rdbc2bc.discunif(-1, 1)
        rdbc2mc.discunif(-3, 3)

        // MC -> {GC, BC, MC, HC}
        rdmc2gc1 = new Random(rseed)
        rdmc2gc2 = new Random(rseed)
        rdmc2bc = new Random(rseed)
        rdmc2mc = new Random(rseed)	
        rdmc2mc1 = new Random(rseed)
        rdmc2hc = new Random(rseed)
        rdmc2gc1.discunif(25, 175)
        rdmc2gc2.discunif(-175, -25)
        rdmc2bc.discunif(-3,3)
        rdmc2mc.discunif(ngcell+nbcell, ngcell+nbcell+nmcell-1)
        rdmc2mc1.discunif(-3, 3)
        rdmc2hc.discunif(-2, 2)

        // HC -> {GC, BC, MC}
        rdhc2gc = new Random(rseed)	
        rdhc2bc = new Random(rseed)
        rdhc2mc = new Random(rseed)				
        rdhc2gc.discunif(-130, 130)
        rdhc2bc.discunif(-2, 2)
        rdhc2mc.discunif(-2, 2)

        // PP -> {GC, BC, HC}
        rnd_pp2gc  = new Random(rseed)    
        rnd_pp2bc  = new Random(rseed)
        rnd_pp2hc  = new Random(rseed)
        rnd_pp2gc.discunif(0,npp-1)
        rnd_pp2bc.discunif(0,npp-1)
        rnd_pp2hc.discunif(0,npp-1)

        // RNGs for synapses
        rdsyna = new Random(rseed)
        rdsynb = new Random(rseed)
        rdsyna.discunif(0, 1)
        rdsynb.discunif(0, 3)
    }

    proc set_data_management_params(){
        /* Parameters for how data are managed during the simulation. 
        */

        // Define file names for simulation results output
        //  [TODO] MODIFY THIS APPROPRIATELY 
        strdef suffix, idname 
        suffix = "txt"
        idname = "-pp10-gaba1-kir1-st0"

        strdef init_state_fname_
        init_state_fname_ = "NetworkState_init_10Hz.dat"

        // Flags about what to print
        print_Vtrace 	= 1             // print voltage trace to file
        print_Raster 	= 1             // print spike raster to file
        print_template 	= 1             // write out spike sequence into template file
        print_GC_sprouting_input_ = 0	// calculates and print out GC sprouting input number distribution
        print_stim_ 	 = 1             // print stimulus to GCs for debug purpose..
        print_stim_noise = 1            // print noise to GCs for debug purpose.. (same output file as Poisson input to GCs!)
    }

    proc set_neuron_population_sizes(){
        /* Initialize the number of cells of each type in the networks
        */
        ngcell = 500		    // number of GCs 
        nbcell = 6              // number of BCs (Samathakumar 2005)
        nmcell = 15		        // number of MCs	
        nhcell = 6              // number of HCs (Samathakumar 2005)
        npp = 100               // ECII Neurons (Myers and Scharfman, 2009)
        nmcell_per_lamella = 3  // Number of mossy cells per lamella

        // Add 2*npp because of PP input and PP noise...
        ntotal = ngcell + nbcell + nmcell + nhcell + npp + npp

    }

    proc set_perforant_path_input_params() {
        /*  Set parameters for the perforant path stimulation 
        */
        PP_nstimulus_ 	= 1         // one input per GC
        PP_input2MC_  	= 0         // stimulate MC with PP
        PP_rate_        = 10.       // rate of PP Poisson input
        PP_rate_noise_  = 0.        // rate of PP Poisson noise
        PP_box_nr_      = 6         // number of active PPs
        PP_box_stop_	= 35.       // time of box [ms]
        PP_box_start_	= 5.        // shift of box [ms]
        PP_box_nspk_    = 3         // number of spike per active PP

        if (PP_input2MC_ != 0) {
            print "PP stimulation not yet implemented if stimulation of also MCs...."      
            quit()
        }
    }

    proc set_connectivity_params() {
        /* Parameters related to network connectivity 

        Arguments: 

        */
        p_sprouted_ = 0     // proportion of other GCs to which a GC will connect 
        scale_gpas_dg_       = 100    // scaling [%] of gpas of th GC model (100% in the original file)
        scale_sk_dg_         = 100    // scaling of Ca-dependent K (SK) of th GC model (100% in the original file)
        scale_kir_           = 100    // scaling of KIR conductance in GC model
        scale_gabaa_         = 100    // scaling of GABAA in GC model
        scale_PP_strength    = 10    	// scaling of synaptic weight of PP
        scale_PP2BC_strength = 100    // scaling of synaptic weight PP->BC (100% for original value which was 50% of PP->GC strength..)
        scale_PP2HC_strength = 0      // scaling of synaptic weight PP->HIPP (set to 0% for Santhakumar because there no PP->HIPP connections...)
        scale_HC2GC_strength = 100    // scaling of synaptic weight HC->GC (beta_HIPP in Myers and Scharfman, 2009)
        scale_MC2GC_strength = 100    // scaling of synaptic weight MC->GC (beta_HIPP in Myers and Scharfman, 2009)
        scale_GC2BC_strength = 300    // scaling of synaptic weight GC->BC
        scale_BC2GC_strength = 300    // scaling of synaptic weight BC->GC

    }

    proc yim_param_modifications() {
        /* Reset parameters to generate the figures in Yim et al (2015)

        Arguments:
            $1 : int : Which figure you are trying to generate data for

        */
        fig = $1
        if (fig == 1) {
            scale_PP_strength   = 10
            scale_kir_          = 100
            scale_gabaa_        = 100
            p_sprouted_         = 0
            idname = "-pp10-gaba1-kir1-st0"
        }

        if (fig == 2) {
            scale_PP_strength   = 10
            scale_kir_          = 100
            scale_gabaa_        = 100
            p_sprouted_         = 30
            idname = "-pp10-gaba1-kir1-st30"
        }

        if (fig == 3) {
            scale_PP_strength   = 10
            scale_kir_          = 400
            scale_gabaa_        = 400
            p_sprouted_         = 30
            idname = "-pp10-gaba4-kir4-st30"
        }

        if (fig == 4) {
            scale_PP_strength   = 16
            scale_kir_          = 100
            scale_gabaa_        = 100
            p_sprouted_         = 10
            idname = "-pp16-gaba1-kir1-st10"
        }

        if (fig == 5) {
            scale_PP_strength   = 16
            scale_kir_          = 400
            scale_gabaa_        = 400
            p_sprouted_         = 10
            idname = "-pp16-gaba4-kir4-st10"
        }
    } 

    proc make_cells() {local i
        // Need to re-declare cell arrays with proper sizes
        objref Gcell[ngcell], Bcell[nbcell], Mcell[nmcell], Hcell[nhcell]
        objref PPSt[npp], PPSt_noise[npp]
        cells = new List()

        // Create populations 
        for i=0, ngcell-1 {Gcell[i] = new GranuleCell(i,scale_gpas_dg_, scale_sk_dg_, scale_gabaa_, scale_kir_)}
        for i=0, nbcell-1 {Bcell[i] = new BasketCell(i)}
        for i=0, nmcell-1 {Mcell[i] = new MossyCell(i)}
        for i=0, nhcell-1 {Hcell[i] = new HIPPCell(i)}
        for i=0, npp-1 	  {PPSt[i] = new PPstim(i, PP_rate_, tstop, PP_box_start_, PP_box_stop_)}
        for i=0, npp-1    {PPSt_noise[i] = new PPstim(i, PP_rate_, tstop, PP_box_start_, PP_box_stop_)}

        // Append to cells list
        for i = 0, ngcell-1 {cells.append(Gcell[i])} 	// cells 0-499 GCs
        for i = 0, nbcell-1 {cells.append(Bcell[i])} 	// cells 500-505 BC
        for i = 0, nmcell-1 {cells.append(Mcell[i])} 	// cells 506-520 MC
        for i = 0, nhcell-1 {cells.append(Hcell[i])} 	// cells 521-526 HC
        for i = 0, npp-1 {cells.append(PPSt[i])}		// 527 - xxx PP artificial cell
        for i = 0, npp-1 {cells.append(PPSt_noise[i])}  
    }

    proc make_connections(){
        /* Instantiates connectivity in the network
        */
        // Instantiate the connectivity list 
        nclist = new List()


        // Instantiate vectors for connections
        //      GC -> {GC, BC, MC, HC} 
        vgc2gc = new Vector(ngcell, 0)
        vgc2bc = new Vector(nbcell, 0)
        vgc2mc = new Vector(nmcell, 0)
        vgc2hc = new Vector(nhcell, 0)

        //      BC -> {GC, BC, MC}
        vbc2gc = new Vector(ngcell, 0)
        vbc2bc = new Vector(nbcell, 0)
        vbc2mc = new Vector(nmcell, 0)

        //      MC -> {GC, BC, MC, HC}
        vmc2gc = new Vector(ngcell, 0)
        vmc2bc = new Vector(nbcell, 0)
        vmc2mc = new Vector(nmcell, 0)
        vmc2hc = new Vector(nhcell, 0)

        //      HC -> {GC, BC, MC}
        vhc2gc = new Vector(ngcell, 0)
        vhc2bc = new Vector(nbcell, 0)
        vhc2mc = new Vector(nmcell, 0)


        // Connect areas 
        connect_pp_to_gc()
        connect_pp_to_bc()
        connect_pp_to_hipp()
        connect_granule_cells()
        connect_basket_cells()
        // connect_mossy_cells()
        // connect_hipp_cells()
    }

    func nc_append() {	
        // neuron connect $1 with $2.pre_list.object($3), weight $4, delay $5, threshold $6
        // connects:
        // cells.object($1)                             with
        // $o1 = cells.object($2).pre_list.object($3)   and
        // returns:
        // netcon = $o2

        if ($3 >= 0 )	{
            //  connect_pre is function in the respective cell definition
            cells.object($1).connect_pre(cells.object($2).pre_list.object($3),netcon)	
            netcon.weight = $4
            netcon.delay = $5
            netcon.threshold = $6
        }       
        nclist.append(netcon)
        return nclist.count-1
    }

    func nc_append_rec() { 
        /* neuron connect $1 with $2.pre_list.object($3), weight $4, delay $5, threshold $6
        // connects:
        // cells.object($1)                             with
        // $o1 = cells.object($2).pre_list.object($3)   and
        // returns:
        // netcon = $o2
        // record events to $o7
        */

        if ($3 >= 0 )   {
            //  connect_pre is function in the respective cell definition
            cells.object($1).connect_pre(cells.object($2).pre_list.object($3),netcon)       
            netcon.weight = $4
            netcon.delay = $5
            netcon.threshold = $6
            netcon.record($o7)
        }
        nclist.append(netcon)
        return nclist.count-1
    }

    func is_connected() {local i, c localobj net_c
        /* Checks for preexisting connections between randomly selected cells
        to avoid multiple contacts between same 2 cells
        */
        c=0
        for i=0, nclist.count-1 {
            net_c = nclist.object(i)
            if (($o1 == net_c.postcell())  && ($o2 == net_c.precell())) {c=1}
        }
        return c
    }

    proc connect_pp_to_gc() { local i, j localobj pprec
        /* Function that connects perforant path inputs to granule cells
        */
        // Print message to indicate procedure 
        print "Connecting PP -> GC."

        // Create vector that marks PP neurons that already project to a GC
        pprec =  new Vector(npp, 0) 

        // Objects to record inputs/noise for debugging [TODO] verify necessity...
        //      Must be re-declared with proper value of npp
        objref vec_stim[npp], vec_stim_noise[npp]
        for i = 0, npp-1 { vec_stim[i] = new Vector() }
        for i = 0, npp-1 { vec_stim_noise[i] = new Vector() }

        // Make connections for each individual GC
        for i=0, ngcell-1 {
            // Re-initialize connectivity vector to prevent multiple stimulation 
            // connections from the same PP cell
            pp2gc = new Vector(npp, 0)	

            // Each GC receives input from random set of 20% of PP neurons
            // [ TODO ] - ALLOW TO HAVE 20% CHANGED TO DIFFERENT VALUES
            for nr_conn = 0, int(npp/5.) - 1 {
                // Pick a random PP cell to connect to the GC
                // Repeat until j is a PP cell that is not yet connected
                // Then mark j as connected so it is not chosen again 
                j = rnd_pp2gc.repick()
                while (pp2gc.x[j] == 1)	{ 
                    j = rnd_pp2gc.repick() 
                }
                pp2gc.x[j] = 1
                
                if ((print_stim_==1) && (i<npp)) {
                    if (pprec.x[j] == 0) {
                        // record input sequence to first neuron for debug purpose only....
                        nc_append_rec(j+ngcell+nbcell+nmcell+nhcell, i, 0, 2e-2*scale_PP_strength/100., 3, 10, vec_stim[j]) 
                        pprec.x[j] = 1
                    } else {
                        // record input sequence to first neuron for debug purpose only....
                        nc_append(j+ngcell+nbcell+nmcell+nhcell, i, 0, 2e-2*scale_PP_strength/100., 3, 10)
                    }
                } else {
                    // connect PP to GC[j],syn[0],wt,del,threshold   <AH> NOTE both synapses are equal, ie. weight delay (except position) not important
                    nc_append(j+ngcell+nbcell+nmcell+nhcell, i, 0, 2e-2*scale_PP_strength/100., 3, 10)
                }
            }
            
            // Print debugging message 
            if (debug_ == 3) {
                print "\nGC: ",i
                for ii=0,pp2gc.size()-1 { printf ("%d, ",pp2gc.x[ii]) }
            }
        }
    }

    proc connect_pp_to_bc() { local i,j 
        /* Connect perforant path inputs to basket cells 
        */
        // Print message to indicate procedure 
        print "Connecting PP -> BC."

        // Only proceed if there are PP to BC connections
        if (scale_PP2BC_strength != 0) {
            for i=ngcell, ngcell+nbcell-1 {
                pp2bc = new Vector(npp, 0)

                // Each BC receives input from random set of 20% of PP neurons
                // [ TODO ] - ALLOW TO HAVE 20% CHANGED TO DIFFERENT VALUES
                for nr_conn = 0, int(npp/5.)-1 {
                    j = rnd_pp2bc.repick()
                    while (pp2bc.x[j] == 1)  { j = rnd_pp2bc.repick() }
                    pp2bc.x[j] = 1
                    
                    // connect PP to BC[j],syn[0],wt,del,threshold   <AH> NOTE both synapses are equal
                    nc_append(j+ngcell+nbcell+nmcell+nhcell, i, 0, 1e-2*scale_PP_strength/100.*scale_PP2BC_strength/100., 3, 10)
                }

                // Print debugging message 
                if (debug_ == 3) {
                    print "\nBC: ",i
                    for ii=0,pp2bc.size()-1{ printf ("%d, ",pp2gc.x[ii])}
                }
            }
        }
    }

    proc connect_pp_to_hipp() { local i,j 
        /* Connecting perorant path to HIPP cells 
        */
        if (scale_PP2HC_strength != 0) {
            print "Connecting PP -> HIPP."
            
            for i=0, nhcell-1 {
                pp2hc = new Vector(npp, 0)

                // Each HIPP receives input from random set of 20% of PP neurons
                // [ TODO ] - ALLOW TO HAVE 20% CHANGED TO DIFFERENT VALUES
                for nr_conn = 0, int(npp/5.)-1 {
                    j = rnd_pp2hc.repick()
                    while (pp2hc.x[j] == 1) { j = rnd_pp2hc.repick() }
                    pp2hc.x[j] = 1
                    
                    // used here synaptic strength of GC->HIPP / connections PP-> HIPP not in Santhakumar 2005
                    nc_append(j+ngcell+nbcell+nmcell+nhcell, i+ngcell+nbcell+nmcell, 0, 0.5e-3*scale_PP_strength/100.*scale_PP2HC_strength/100., 3, 10)

                }
                if (debug_ == 3) {
                    print "\nHIPP: ",i
                    for ii=0,pp2bc.size()-1{ printf ("%d, ",pp2hc.x[ii])}
                }
            }
            if (debug_ == 3) { print "PP -> HIPP -DONE-" }
        }
    }

    proc connect_granule_cells() { local i,j localobj c1, c2
        /* Connect granule cells to post-synaptic targets 
        */
        // Print to indicate step
        print "Connecting GCs to post-synaptic targets."

        if (debug_ == 0) { print "n_sprout_ = ",n_sprout_ }
        if (p_sprouted_>0 && debug_ == 2) {print "NOTE: we have sprouting connections..."}

        for  i=0, ngcell-1 {
            // CONNECT GC'S TO BC'S
            for j=0, 0 {	
                // Which lamella is GC[i] in wrt basket cells 
                // Note: one basket cell per lamella
                // [ TODO ] - Allow for more than one BC per lamella
                if (i < ngcell/nbcell) { a=0 }
                if ((i > ngcell/nbcell-1) && (i < ngcell*2/nbcell)) { a=1 }
                if ((i > ngcell*2/nbcell-1) && (i < ngcell*3/nbcell)) { a=2 }
                if ((i > ngcell*3/nbcell-1) && (i < ngcell*4/nbcell)) { a=3 }
                if ((i > ngcell*4/nbcell-1) && (i < ngcell*5/nbcell)) { a=4 }
                if ((i > ngcell*5/nbcell-1) && (i < ngcell)) { a=5}

                // Randomly pick location of post synaptic Bcell from distribution [-1:1]
                Gauz3 = rdgc2bc.repick()

                // Determine appropriate post syn BC
                if (a+Gauz3 > nbcell-1) { npost = a+Gauz3-nbcell } 		
                if (a+Gauz3 < 0) { npost = a+Gauz3+nbcell } 
                if ((a+Gauz3 > -1) && (a+Gauz3 < nbcell)) {npost = a+Gauz3}

                // randomly pick the dendrite to connect to from [0:3] ( i.e. // randomize among 4 dendrites )
                dbr = rdsynb.repick() 						
                if (debug_ == 1 ) { 
                    print "GC \t",i,"\t to BC\t\t",npost, a
                }

                // check to make sure that post syn BC does not get more than 90 GC synapses
                // [ TODO ] - ALLOW FOR DIFFERENT NUMBER OF MAX SYNAPSES
                if (vgc2bc.x[npost] < 90) { 					
                    // connect GC[i] to BC[j],syn[2]+dendritic_var,wt,del,threshold
                    nc_append(i, ngcell+npost, dbr+2, 4.7e-3*scale_GC2BC_strength/100., .8, 10)
                    
                    if (debug_ == 0 ) { 
                        print "GC \t",i,"\t to BC\t\t",npost,"\t",dbr+2 
                    }
                    
                    // increment the no of synapses to the post cell
                    vgc2bc.x[npost]  +=1

                } else {
                    j -= 1	
                    if (debug_ == 1 ) {print "nogc2bc"}
                } // for connection that is not made reconnect axon to another cell
            }

            // CONNECT GC'S TO MC'S
            for j=0, 0 {
                // Based on the lamellar distribution of the GCs to MCs - 500 GCs were divided into 5 groups, 3 MCs were distributed in each lamella
                // print "Based on the lamellar distribution of the GCs to MCs..."
                // [ TODO ] - Allow for different number of MC's per lamella
                if (i < ngcell/5) { a=0}
                if ((i > ngcell/5-1) && (i < ngcell*2/5)) { a=1}
                if ((i > ngcell*2/5-1) && (i < ngcell*3/5)) { a=2}
                if ((i > ngcell*3/5-1) && (i < ngcell*4/5)) { a=3}
                if ((i > ngcell*4/5-1) && (i < ngcell)) { a=4}
                b=a*3						// from [0:12]
                npost = rdgc2mc.repick()	// from [0:2]
                dbr = rdsynb.repick()		// from [0:2]


                // [ TODO ] - ALLOW FOR DIFFERENT NUMBER OF MAX SYNAPSES
                if (vgc2mc.x[npost+b] < 38){
                    nc_append(i, ngcell+nbcell+npost+b, dbr+4, 0.2e-3, 1.5, 10)
                    
                    if (debug_ == 1 ) {
                        print "GC \t",i,"\t to MC\t\t", npost+b, "\t", dbr+4
                    }

                    vgc2mc.x[npost+b] +=1
                } else {
                    j -= 1
                    if (debug_ == 1 ) {
                        print "nogc2mc"
                    }
                }
            }

            // CONNECT GC's to HIPP
            for j=0, 2 {
                // <AH> comment added:
                // Based on the lamellar distribution of the GCs to HIPPs - 500 GCs were divided into 6 groups
                if (i < ngcell/6) { a=0}
                if ((i > ngcell/6-1) && (i < ngcell*2/6)) { a=1}
                if ((i > ngcell*2/6-1) && (i < ngcell*3/6)) { a=2}
                if ((i > ngcell*3/6-1) && (i < ngcell*4/6)) { a=3}
                if ((i > ngcell*4/6-1) && (i < ngcell*5/6)) { a=4}
                if ((i > ngcell*5/6-1) && (i < ngcell)) { a=5}

                Gauz3 = rdgc2hc.repick()	
                if (a+Gauz3 > nhcell-1) { npost = a+Gauz3-nhcell }
                if (a+Gauz3 < 0) { npost = a+Gauz3+nhcell } 
                if ((a+Gauz3 > -1) && (a+Gauz3 < nhcell)) { npost = a+Gauz3 }
                
                dbr = rdsynb.repick()
                c1 = cells.object(ngcell+nbcell+nmcell+npost)
                c2 = cells.object(i)
                if ((is_connected(c1, c2) == 0) && (vgc2hc.x[npost] < 275)) {
                    nc_append(i, ngcell+nbcell+nmcell+npost, dbr, 0.5e-3, 1.5, 10)
                    if (debug_ == 1 ) {
                        print "GC \t",i,"\t to HC\t\t",npost, "\t", dbr
                    }
                    vgc2hc.x[npost] +=1
                } else {
                    j -= 1
                }
            }

            // GCs -> GCs
            // NOTE: THIS IS FOR SPROUTED SYNAPSES
            // NOTE: 100% Sprouting = 100 new synapses! (compare p. 443 in Santhakumar paper)
            n_sprout_ =  p_sprouted_ - 1				

            // 9 in original file // each GC is recurrent connected to 10 GC  
            // (i.e. 10/500 => p = 0.02) but sprouting is diff different -> see above
            for j=0, n_sprout_  {
                Gauz3 = rdgc2gc.repick()
                if (i+Gauz3 > 499) { npost = i+Gauz3-500 }
                if (i+Gauz3 < 0) { npost = i+Gauz3+500 } 
                if ((i+Gauz3 > -1) && (i+Gauz3 < 500)) { npost = i+Gauz3 }

                dbr = rdsyna.repick()				// [0:1]
                c1 = cells.object(npost)
                c2 = cells.object(i)
                if ((is_connected(c1, c2) == 0) && (vgc2gc.x[npost] < (n_sprout_*1.5+2) )) {	// if is connected AND not more than 14 incoming connections...
                                                                     //  (original file < 15) (assume 1.5 times average connections for upper limit...)
                    nc_append(i, npost, dbr+7, 2e-3, .8, 10)  							// Gcell[3] to Bcell[1]
                    //	print npost, dbr+8					
                    if (debug_ == 0 ) {print "GC \t",i,"\t to GC\t\t",npost, "\t", dbr+7}
                    vgc2gc.x[npost] +=1
                } else {
                    j -= 1	
                    if (debug_ == 0) {print "gc2gc"}
                }
            }
        }

        if (print_GC_sprouting_input_ == 1) {
            distri_gc_input_ = new Vector()
            max_gc_input_  = 0 
            if (debug_ ==2) { print "Calculate GC-GC Input Distribution"}

            for zz = 0, int(n_sprout_*1.5+2)  {distri_gc_input_.append(0)}
            for npost=0,ngcell-1 {
                distri_gc_input_.x[vgc2gc.x[npost]]+=1
                if (vgc2gc.x[npost]>max_gc_input_) { max_gc_input_ = vgc2gc.x[npost]}		// find max input number 
            }
            for zz = 0, int(n_sprout_*1.5+2)  {print zz,"\t",distri_gc_input_.x[zz]}
            print "maximum input number is:\t",max_gc_input_
        }	
    }

    proc connect_basket_cells() { local i,j localobj c1, c2
        print "Connecting Basket Cells. "

        for  i=0, nbcell-1 {
            // BC -> GC 
            // [ TODO ] - Allow for different lamella sizes
            for j=0, 99 {
                Gauz3 = rdbc2gc.repick()    // [-70:70]
                if (debug_ == 1 ) {print Gauz3}
                if (i*83+41+Gauz3 > 499) {npost = i*83+41+Gauz3-500 }
                if (i*83+41+Gauz3 < 0) {npost = i*83+41+Gauz3+500} 
                if ((i*83+41+Gauz3 > -1) && (i*83+41+Gauz3 < 500)) {npost = i*83+41+Gauz3}
                if (debug_ == 1 ) {print i, npost}
                if (nbcell != 6) {max_conn = 4} else {max_conn = 2}								// if not original setup use more spread...
                c1 = cells.object(npost)
                c2 = cells.object(i+ngcell)
                if ((is_connected(c1, c2) == 0) && (vbc2gc.x[npost] < max_conn)) {	// change < 2 to < 4
                    nc_append(i+ngcell, npost, 6, 1.6e-3*scale_BC2GC_strength/100, .85, -10)  
                    vbc2gc.x[npost] +=1
                    if (debug_ == 1 ) { print i, npost, 6 }
                } else {
                    j -= 1
                    if (debug_ == 1 ) {print "BC2GC"}
                }
            }

            // BC -> BC
            for j=0, 1 {
                Gauz3  = rdbc2bc.repick()		// [-1,0,1] (postsyn spread around single id...)
                //print Gauz3
                if (i+Gauz3 > nbcell-1) {npost = i+Gauz3-nbcell }	 // periodic boundary conditions 
                if (i+Gauz3 < 0) {npost = i+Gauz3+nbcell} 
                if ((i+Gauz3 >-1) && (i+Gauz3 < nbcell)) {npost = i+Gauz3}
                dbr = rdsyna.repick()		// [0:1]
                if (nbcell != 6) {max_conn = 4} else {max_conn = 3} 
                c1 = cells.object(npost+ngcell)
                c2 = cells.object(i+ngcell)
                if ((is_connected(c1, c2) == 0) && (vbc2bc.x[npost] < max_conn)) {			// change < 3 to < 4
                    nc_append(i+ngcell, npost+ngcell, dbr+8, 7.6e-3, .8, -10)  
                    if (debug_ == 1 ) {print npost, dbr+8}
                    vbc2bc.x[npost] +=1
                } else {
                    j -= 1	
                    if (debug_ == 1 ) {print "bc2bc"}
                }
            }

            // BC -> MC
            for j=0, 2 {
                Gauz3 = rdbc2mc.repick()				// [-3:3]
                if (i*2+2+Gauz3 > 14) {npost = i*2+2+Gauz3-15 }
                if (i*2+2+Gauz3 < 0) {npost = i*2+2+Gauz3+15} 
                if ((i*2+2+Gauz3 >-1) && (i*2+2+Gauz3 < 15)) {npost = i*2+2+Gauz3}
            //	if ((is_connected(MossyCell[npost], BasketCell[i]) == 0) && (vbc2mc.x[npost] < 3) && (killMC.contains(ngcell+nbcell+npost) == 0)) {	// use if killing MC
                if (nbcell != 6) {max_conn = 4} else {max_conn = 3} 

                c1 = cells.object(npost+ngcell+nbcell)
                c2 = cells.object(i+ngcell)
                if ((is_connected(c1, c2) == 0) && (vbc2mc.x[npost] < max_conn)) {			// change < 3 to < 4
                nc_append(i+ngcell, npost+ngcell+nbcell, 12, 1.5e-3, 1.5, -10)  // Gcell[3] to Bcell[1]
                if (debug_ == 1 ) {print npost, 12}
                vbc2mc.x[npost] +=1
                } else {	
                    j -= 1	
                    if (debug_ == 1 ) {print "bc2mc"}
                }
            //	if (killMC.contains(ngcell+nbcell+npost) == 1) {j +=1 if (debug_ == 1 ) {print "dead MC"}}	// use if killing MC
            }
        }
    }


    // proc connect_mossy_cells() {local i,j 
    //     if (debug_ ==2 ) { 
    //         print "Mossy Cell post synaptic connections"
    //     }

    //     for  i=0, nmcell-1 {
            
    //         //if (killMC.contains(ngcell+nbcell+i) == 0) 	// use if killing MC
    //         if (i < 3) { y=0 }
    //         if ((i > 2) && (i < 6)) { y=1 }
    //         if ((i > 5) && (i < 9)) { y=2 }
    //         if ((i > 8) && (i < 12)) { y=3 }
    //         if ((i > 11) && (i < 15)) { y=4 }
            
    //         // MC -> GC1
    //         for j=0, 99 {
    //             Gauz1 = rdmc2gc1.repick()		// [25:175]
    //             if (i*33+17+Gauz1 > 499) {
    //                 npost1 = i*33+17+Gauz1-500
    //             } else {
    //                 npost1 =i*33+17+Gauz1
    //             }
                
    //             dbr = rdsyna.repick()			// [0:1]
    //             if ((is_connected(GranuleCell[npost1], MossyCell[i]) == 0) && (vmc2gc.x[npost1] < 7))  {
    //                 nc_append(i+ngcell+nbcell, npost1, dbr+2, 0.3e-3*scale_MC2GC_strength/100., 3, 10)
    //                 vmc2gc.x[npost1] +=1
    //             } else { 
    //                 j -= 1	
    //             } 
    //         }

    //         // MC -> GC2
    //         for j=0, 99 {
    //             Gauz2 = rdmc2gc2.repick()		// [-175:25]
    //             if (i*33+17+Gauz2 < 0) {
    //                 npost2 =i*33+17+Gauz2+500
    //             } else {npost2 =i*33+17+Gauz2}
    //                 dbr = rdsyna.repick()			// [0:1]
    //             if ((is_connected(GranuleCell[npost2], MossyCell[i]) == 0) && (vmc2gc.x[npost2] < 7))  {
    //                 nc_append(i+ngcell+nbcell, npost2, dbr+2, 0.3e-3*scale_MC2GC_strength/100., 3, 10)  // Gcell[3] to Bcell[1]
    //                 vmc2gc.x[npost2] +=1
    //             } else { 
    //                 j -= 1	 
    //             }
    //         }


    //         // MC -> BC
    //         for j=0, 0 {
    //             Gauz3 = rdmc2bc.repick()						    // Gauz3 = [-3:3]	
    //             if (y+Gauz3 > nbcell-1) {npost = y+Gauz3-nbcell}    // y     = [0:4] 	=> y+Gaus3 = [-3:7]
    //             if (y+Gauz3 < 0) {npost = y+Gauz3+nbcell} 
    //             if ((y+Gauz3 > -1) && (y+Gauz3 < nbcell)) {npost = y+Gauz3}
    //             dbr = rdsyna.repick()
    //             if ((vmc2bc.x[npost] < 4) && (Gauz3 !=0)) {
    //                 nc_append(i+ngcell+nbcell, ngcell+npost, dbr+6, 0.3e-3, 3, 10)  // Gcell[3] to Bcell[1]
    //                 vmc2bc.x[npost] += 1
    //             } else { 
    //                 j -= 1	 
    //             } 
    //         }


    //         // MC -> MC 
    //         for j=0, 2 {
    //             Gauz3 = rdmc2mc1.repick()		//[-3:3]
    //             if (i+Gauz3 > 14) {npost = i+Gauz3-15 }
    //             if (i+Gauz3 < 0) {npost = i+Gauz3+15} 
    //             if ((i+Gauz3 >-1) && (i+Gauz3 < 15)) {npost = i+Gauz3}
    //             dbr = rdsynb.repick()
    //             //	if ((is_connected(MossyCell[npost], MossyCell[i]) == 0) && (vmc2mc.x[npost] < 4) && (Gauz3 != 0) && (killMC.contains(ngcell+nbcell+npost) == 0))  	// use if killing MC
    //             if ((is_connected(MossyCell[npost], MossyCell[i]) == 0) && (vmc2mc.x[npost] < 4) && (Gauz3 != 0))  {
    //                 nc_append(i+ngcell+nbcell, npost+ngcell+nbcell, dbr+8, 0.5e-3, 2, 10)  // Gcell[3] to Bcell[1]
    //                 //	print npost, dbr+8
    //                 vmc2mc.x[npost] +=1
    //             } else { 
    //                 j -= 1	
    //             }
    //             // 	if (killMC.contains(ngcell+nbcell+npost) == 1){ j += 1 print "dead MC"}	// use if killing MC
    //         }


    //         // MC -> HC
    //         for j=0, 1 {
    //             Gauz3 = rdmc2hc.repick()			// [-2:2]
    //             if (y+Gauz3 > nhcell-1) {npost = y+Gauz3-nhcell}							// changed code here to allow > 6 HCells
    //             if (y+Gauz3 < 0) {npost = y+Gauz3+nhcell} 
    //             if ((y+Gauz3 > -1) && (y+Gauz3 < nhcell)) {npost = y+Gauz3}
    //             dbr = rdsynb.repick()
    //             if ((is_connected(HIPPCell[npost], MossyCell[i]) == 0) && (vmc2hc.x[npost] < 7) && (Gauz3 != 0))  {
    //                 nc_append(i+ngcell+nbcell, ngcell+nbcell+nmcell+npost, dbr+4, 0.2e-3, 3, 10)  // Gcell[3] to Bcell[1]
    //                 //	print npost, dbr+4
    //                 vmc2hc.x[npost] +=1
    //             } else {
    //                 j -= 1	
    //             }
    //         }
    //     }
    // }


    // proc connect_hipp_cells() {local i,j
    //     if (debug_ ==2 ) { print "HIPP Cell post synaptic connections"}
    //     for  i=0, nhcell-1 {

    //         // HC -> GC
    //         for j=0, 159 {											// NOTE number of connections explicitly coded here!
    //             Gauz3 = rdhc2gc.repick()									// [-130:130]
    //             //print Gauz3
    //             if (i*83+41+Gauz3 > 499) {npost = i*83+41+Gauz3-500 }						// NOTE: 500 is explicitly coded here!
    //             if (i*83+41+Gauz3 < 0) {npost = i*83+41+Gauz3+500} 
    //             if ((i*83+41+Gauz3 > -1) && (i*83+41+Gauz3 < 500)) {npost = i*83+41+Gauz3}
    //             //print npost
    //             dbr = rdsyna.repick()
    //             if (nhcell != 6) {max_conn = 5} else {max_conn = 3}
    //             if ((is_connected(GranuleCell[npost], HIPPCell[i]) == 0) && (vhc2gc.x[npost] < max_conn))  {		// NOTE < 3 coded explicitly here! -> change to 5
    //                 nc_append(i+ngcell+nbcell+nmcell, npost, dbr+4, 0.5e-3*scale_HC2GC_strength/100., 1.6, 10)  			// Hcell to Gcell
    //                 vhc2gc.x[npost] +=1
    //                 if (debug_ == 1 ) {print i, npost, dbr+4}
    //             } else {
    //                 j -= 1	
    //                 if (debug_ == 1 ) {print "HC2GC"}
    //             }
    //         }

    //         // HC -> BC
    //         for j=0, 3 {
    //             Gauz3 = rdhc2bc.repick()									// [-2:2]
    //             if (i+Gauz3 > nbcell-1) {npost = i+Gauz3-nbcell}
    //             if (i+Gauz3 < 0) {npost = i+Gauz3+nbcell} 
    //             if ((i+Gauz3 > -1) && (i+Gauz3 < nbcell)) {npost = i+Gauz3}
    //             dbr = rdsyna.repick()
    //             if ((is_connected(BasketCell[npost], HIPPCell[i]) == 0) && (vhc2bc.x[npost] < 5))  {		// NOTE < 5 coded explicitly here!
    //                 nc_append(i+ngcell+nbcell+nmcell, npost+ngcell, dbr+10, 0.5e-3, 1.6, 10)  		// Hcell to Bcell
    //                 if (debug_ == 1 ) {print npost, dbr+10}
    //                 vhc2bc.x[npost] += 1
    //             } else {
    //                 j -= 1	
    //                 if (debug_ == 1 ) {print "HC2BC"}
    //             }
    //         }

    //         // HC -> MC
    //         for j=0, 3 {							
    //             Gauz3 = rdhc2mc.repick()									// [-2:2]
    //             //print Gauz3
    //             if (i*2+2+Gauz3 > 14) {npost = i*2+2+Gauz3-15 }
    //             if (i*2+2+Gauz3 < 0) {npost = i*2+2+Gauz3+15} 
    //             if ((i*2+2+Gauz3 >-1) && (i*2+2+Gauz3 < 15)) {npost = i*2+2+Gauz3}
    //             //print npost
    //             dbr = rdsynb.repick()
    //             //	  if ((is_connected(MossyCell[npost], HIPPCell[i]) == 0) && (vhc2mc.x[npost] < 2) && (killMC.contains(ngcell+nbcell+npost) == 0))  	//use if killing MC
    //                 if (nhcell != 6) {max_conn = 4} else {max_conn = 2}
    //             if ((is_connected(MossyCell[npost], HIPPCell[i]) == 0) && (vhc2mc.x[npost] < max_conn))  {		// NOTE < 2 coded explicitly here!!  => changed to 4 
    //                 nc_append(i+ngcell+nbcell+nmcell, npost+ngcell+nbcell, dbr+13, 1.5e-3, 1, 10)  		// Hcell to Mcell
    //                 //if (debug_ == 1 ) {print npost, dbr+13}
    //                 vhc2mc.x[npost] += 1
    //             } else {	
    //                 j -= 1	
    //                 if (debug_ == 1 ) {print "HC2MC"}
    //             }
    //             //  if (killMC.contains(ngcell+nbcell+npost) == 1){ j += 1 print "dead MC"} 			//use if killing MC
    //         }
    //     }
    // }

    proc run() {local i, j
        // INITIALIZE DATA CONTAINERS
        // Need to re-declare Spike and Spike_times with proper size
        objref Spike[ntotal-1], Spike_times[ntotal-1]
        for i=0, (ngcell+nbcell +nmcell +nhcell -1) {
            // vector of spikes for each cell
            Spike[i] = new Vector()      
            // vector of spike times for each cell  
            Spike_times[i] = new Vector()
        }
        
        strdef Spkstr           // What is this?
        dfile = new File()

    }

endtemplate DentateGyrus 



// Need to declare global seed here for ranstream object

global_seed = 1 

objref dg 
dg = new DentateGyrus(1, global_seed)
print dg.ngcell